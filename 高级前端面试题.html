<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>前端面试题</title>
</head>

<body>
  <div style="width:800px;margin:0 auto">
    <h1>前端面试题</h1>
    <h2>HTML</h2>
    <h3>1.XHTML和HTML有什么区别</h3>
    <pre>
HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言
最主要的不同：
XHTML 元素必须被正确地嵌套。
XHTML 元素必须被关闭。
标签名必须用小写字母。
XHTML 文档必须拥有根元素。
</pre>
    <h3>2.Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义</h3>
<pre>
&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档。
严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。
在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。
用于声明文档使用那种规范（html/xhtml）一般为 严格 过度 基于框架的html文档
加入XMl声明可触发，解析方式更改为IE5.5 拥有IE5.5的bug
</pre>
    <h3>3.常见兼容性问题</h3>
    <pre>
* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.
* 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。
* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 
浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 
这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
渐进识别的方式，从总体中逐渐排除局部。
 

首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 
接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
css
.bb{
    background-color:#f1ee18;/*所有识别*/
   .background-color:#00deff\9; /*IE6、7、8识别*/
   +background-color:#a200ff;/*IE6、7识别*/
   _background-color:#1e0bd1;/*IE6识别*/
}
* IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性; 
Firefox下,只能使用getAttribute()获取自定义属性. 
解决方法:统一通过getAttribute()获取自定义属性. 
* IE下,even对象有x,y属性,但是没有pageX,pageY属性; 
Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. 
* 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 
* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 
解决. 超链接访问过后hover样式就不出现了 
被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: 
L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 
</pre>
    <h3>4. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题，如何区分 HTML 和 HTML5</h3>
<pre>
* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

* 绘画 canvas  
  用于媒介回放的 video 和 audio 元素 
  本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
 sessionStorage 的数据在浏览器关闭后自动删除

  语意化更好的内容元素，比如 article、footer、header、nav、section 
 表单控件，calendar、date、time、email、url、search  
新的技术webworker, websockt, Geolocation

 移除的元素

纯表现的元素：basefont，big，center，font, s，strike，tt，u；

对可用性产生负面影响的元素：frame，frameset，noframes；
支持HTML5新标签：

* IE8/IE7/IE6支持通过document.createElement方法产生的标签，
  可以利用这一特性让这些浏览器支持HTML5新标签，

 浏览器支持新标签后，还需要添加标签默认的样式：

* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
   &lt;!--[if lt IE 9]&gt; 
   &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; 
   &lt;![endif]--&gt; 
如何区分： DOCTYPE声明\新增的结构元素\功能元素
</pre>
    <h3>5.语义化的理解</h3>
<pre>
用正确的标签做正确的事情！
html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；
在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。
搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。
使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
</pre>

<h3>6.HTML5的离线储存</h3>
<pre>
localStorage    长期存储数据，浏览器关闭后数据不丢失；
sessionStorage  数据在浏览器关闭后自动删除。
</pre>
<h3>7.(写)描述一段语义的html代码</h3>
<pre>
（HTML5中新增加的很多标签（如：&lt;article&gt;、&lt;nav&gt;、&lt;header&gt;和&lt;footer&gt;等）
 就是基于语义化设计原则）  
    &lt; div id="header"&gt; 
    &lt; h1&gt;标题&lt; /h1&gt; 
    &lt; h2&gt;专注Web前端技术&lt; /h2&gt; 
   &lt; /div&gt;
</pre>
    <h3>8.iframe有那些缺点</h3>
    <pre>
*iframe会阻塞主页面的Onload事件；

*iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
动态给iframe添加src属性值，这样可以可以绕开以上两个问题。
</pre>
    <h3>9.请描述一下 cookies，sessionStorage 和 localStorage 的区别</h3>
    <pre>
cookie在浏览器和服务器间来回传递。 sessionStorage和localStorage不会
sessionStorage和localStorage的存储空间更大；
sessionStorage和localStorage有更多丰富易用的接口；
sessionStorage和localStorage各自独立的存储空间；
</pre>

<h3>10.行内元素有哪些?块级元素有哪些?空(void)元素有那些</h3>
<pre>
块级元素：div p h1 h2 h3 h4 form ul
行内元素: a b br i span input select
知名的空元素： 
&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 
鲜为人知的是： 
&lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;
</pre>

    <h3>11. 你知道多少种Doctype文档类型</h3>
    <pre>
该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
  HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。
  XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。
  Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks
  （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。
   </pre>
<h3>12. 浮动元素引起的问题和解决办法 </h3>
<pre>
浮动元素引起的问题：
（1）父元素的高度无法被撑开，影响与父元素同级的元素
（2）与浮动元素同级的非浮动元素会跟随其后
（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： 
.clearfix:after{
      content: ".";
      display: block;
      height: 0;
      clear: both;
      visibility: hidden;
}
.clearfix{
      display: inline-block;
} /* for IE/Mac */
清除浮动的几种方法： 
1，额外标签法，&lt;div style="clear:both;"&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）
2，使用after伪类
#parent:after{
      content:".";
      height:0;
      visibility:hidden;
      display:block;
      clear:both;
}
3,浮动外部元素
4,设置`overflow`为`hidden`或者auto

13. IE 8以下版本的浏览器中的盒模型有什么不同 
IE8以下浏览器的盒模型中定义的元素的宽高不包括内边距和边框
</pre>
<h3>14. DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h3>
<pre>
（1）创建新节点
      createDocumentFragment()    //创建一个DOM片段
      createElement()   //创建一个具体的元素
      createTextNode()   //创建一个文本节点
（2）添加、移除、替换、插入
      appendChild()
      removeChild()
      replaceChild()
      insertBefore() //在已有的子节点前插入一个新的子节点
（3）查找
      getElementsByTagName()    //通过标签名称
      getElementsByName()    //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)
      getElementById()    //通过元素Id，唯一性
</pre>
<h3>15. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题，如何区分 HTML 和 HTML5 </h3>
<pre>
* HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
* 拖拽释放(Drag and drop) API 
  语义化更好的内容标签（header,nav,footer,aside,article,section）
    音频、视频API(audio,video)
    画布(Canvas) API
    地理(Geolocation) API
    本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
    sessionStorage 的数据在浏览器关闭后自动删除
    表单控件，calendar、date、time、email、url、search  
    新的技术webworker, websocket, Geolocation
* 移除的元素
纯表现的元素：basefont，big，center，font, s，strike，tt，u；
对可用性产生负面影响的元素：frame，frameset，noframes；
支持HTML5新标签：
* IE8/IE7/IE6支持通过document.createElement方法产生的标签，
    可以利用这一特性让这些浏览器支持HTML5新标签，
    浏览器支持新标签后，还需要添加标签默认的样式：
* 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
   &lt;!--[if lt IE 9]&gt; 
   &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt; 
   &lt;![endif]--&gt; 
如何区分： DOCTYPE声明\新增的结构元素\功能元素
</pre>
<h3>16.如何实现浏览器内多个标签页之间的通信 </h3>
<pre>
调用localstorge、cookies等本地存储方式
</pre>
<h3>17.webSocket如何兼容低浏览器</h3>
<pre>
Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR
</pre>
<h3>18.线程与进程的区别 </h3>
<pre>
一个程序至少有一个进程,一个进程至少有一个线程. 
线程的划分尺度小于进程，使得多线程程序的并发性高。 
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。
但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。
但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
</pre>
<h3>19.你如何对网站的文件和资源进行优化</h3>
<pre>
期待的解决方案包括：
   文件合并；文件最小化/文件压缩；使用 CDN 托管；缓存的使用（多个域名来提供缓存）其他
</pre>
<h3>20.请说出三种减少页面加载时间的方法</h3>
<pre>
    1.优化图片 
    2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 
    3.优化CSS（压缩合并css，如margin-top,margin-left...) 
    4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 
    5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，
      如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 
      当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，
      然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）
    6.减少http请求（合并文件，合并图片）。
</pre>
<h3>21.你都使用哪些工具来测试代码的性能</h3>
<pre>
Profiler, JSPerf（http://jsperf.com/nexttick-vs-setzerotimeout-vs- settimeout）, Dromaeo
</pre>
<h3>22.什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC </h3>
<pre>
FOUC - Flash Of Unstyled Content 文档样式闪烁
    &lt;style type="text/css" media="all"&gt;@import "../fouc.css";&lt;/style&gt; 
    而引用CSS文件的@import就是造成这个问题的罪魁祸首。
    IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，
    因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，
    这段时间的长短跟网速，电脑速度都有关系。
    解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。
</pre>
<h3>23.null和undefined的区别 </h3>
<pre>
null是一个表示"无"的对象，转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。 
当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 
undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。典型用法是： 
（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。
null表示"没有对象"，即该处不应该有值。典型用法是： 
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
</pre>
<h3>24.如何判断当前脚本运行在浏览器还是node环境中</h3>
<pre>
通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中。
</pre>
<h3>25、请你谈谈Cookie的弊端 </h3>
<pre>
cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 第一：每个特定的域名下最多生成20个cookie 
    a.IE6或更低版本最多20个cookie
    b.IE7和之后的版本最后可以有50个cookie。
    c.Firefox最多50个cookie
    d.chrome和Safari没有做硬性限制
IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。 
cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 
IE 提供了一种存储可以持久化用户数据，叫做uerData，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。
这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。 
优点：极高的扩展性和可用性 
a.通过良好的编程，控制保存在cookie中的session对象的大小。
b.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。
c.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。
d.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。

缺点： 
a.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。
b.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。
c.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。
</pre>

<h3>26.浏览器本地存储 </h3>
<pre>
在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 
html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 
sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。
因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 
而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。
</pre> 
<h3>27.web storage和cookie的区别 </h3>
<pre>
Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，
并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 
除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 
但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 
浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，
值得一提的是IE总是办好事，例如IE7、 IE6中的UserData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 
localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 
</pre>

<h2>CSS</h2>
<h3>1.介绍一下CSS的盒子模型</h3>
<pre>
（1）有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 pading;
（2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).
</pre>
<h3>2.  CSS 选择符有哪些，哪些属性可以继承，优先级算法如何计算， CSS3新增伪类有哪些</h3>
<pre>
*   1.id选择器（ # myid）
    2.类选择器（.myclassname）
    3.标签选择器（div, h1, p）
    4.相邻选择器（h1 + p）
    5.子选择器（ul &lt; li）
    6.后代选择器（li a）
    7.通配符选择器（ * ）
    8.属性选择器（a[rel = "external"]）
    9.伪类选择器（a: hover, li: nth - child）

*   可继承的样式： font-size font-family color, UL LI DL DD DT;

*   不可继承的样式：border padding margin width height ;

*   优先级就近原则，同权重情况下样式定义最近者为准;

*   载入样式以最后载入的定位为准;
优先级为:
   !important &gt;  id &gt; class &gt; tag  

   important 比 内联优先级高
CSS3新增伪类举例：
p:first-of-type   	选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type   		选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type  		选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child     	选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)   		选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
:enabled  :disabled 控制表单控件的禁用状态。
:checked        	单选框或复选框被选中。
</pre>
 <h3>3.如何居中div？如何居中一个浮动元素</h3>
 <pre>
给div设置一个宽度，然后添加margin:0 auto属性
div{
    width:200px;
    margin:0 auto;
}  
居中一个浮动元素
确定容器的宽高 宽500 高 300 的层
设置层的外边距
.div { 
    Width:500px ; height:300px;//高度可以不设
    Margin: -150px 0 0 -250px;
    position:relative;相对定位
    background-color:pink;//方便看效果
    left:50%;
    top:50%;
} 
</pre>
<h3>4.列出display的值，说明他们的作用。position的值， relative和absolute定位原点是</h3>
<pre>
  1.   
  block 象块类型元素一样显示。
  none 缺省值。象行内元素类型一样显示。
  inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
  list-item 象块类型元素一样显示，并添加样式列表标记。

  2. 
  *absolute 
        生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 
 *fixed （老IE不支持）
        生成绝对定位的元素，相对于浏览器窗口进行定位。 

  *relative 
        生成相对定位的元素，相对于其正常位置进行定位。 
  * static  默认值。没有定位，元素出现在正常的流中
  *（忽略 top, bottom, left, right z-index 声明）。

  * inherit 规定从父元素继承 position 属性的值。
</pre>
<h3>5.CSS3有哪些新特性</h3>
<pre>
  CSS3实现圆角（border-radius:8px），阴影（box-shadow:10px），
  对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
  transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜
  增加了更多的CSS选择器  多背景 rgba 
</pre>
<h3>6.一个满屏品字布局如何设计</h3>
<pre>
* 首先划分成头部、body、脚部；。。。。。
*实现效果图是最基本的工作，精确到2px；
与设计师，产品经理的沟通和项目的参与做好的页面结构，页面重构和用户体验，
处理hack，兼容、写出优美的代码格式，针对服务器的优化、拥抱 HTML5。
</pre>
<h3>7.为什么要初始化CSS样式</h3>
<pre>
- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。

- 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。

*最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）

淘宝的样式初始化：
body, 
h1, 
h2, 
h3, 
h4, 
h5, 
h6, 
hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, 
form, fieldset, legend, button, input, textarea, th, td { 
  margin:0;
  padding:0; 
}
body, 
button, input, select, textarea { 
  font:12px/1.5 tahoma, arial, \5b8b\4f53; 
}
h1, 
h2, 
h3, 
h4, 
h5, 
h6{ 
  font-size:100%; 
}
address, cite, dfn, em, var { 
  font-style:normal;
}
code, 
kbd, pre, 
samp { 
  font-family:couriernew, courier, monospace; 
}
small{
 font-size:12px; 
}

ul, ol { 
  list-style:none;
}
a { 
  text-decoration:none; 
}
a:hover { 
  text-decoration:underline; 
}
sup { 
  vertical-align:text-top; 
}
Sub { 
  vertical-align:text-bottom;
}
legend { 
  color:#000; 
}
fieldset, img { 
  border:0; 
}
button, input, select, textarea { 
  font-size:100%; 
}
table { 
  border-collapse:collapse; 
  border-spacing:0; 
} 
</pre>
<h3>8.absolute的containing block计算方式跟正常流有什么不同</h3>
<pre>
block-level boxes
一个 block-level element ('display'属性值为'block','list-item'或是'table') 会生成一个block-level box，这样的盒子会参与到 block-formatting context (一种布局的方式) 中。
block formatting context
在这种布局方式下，盒子们自所在的 containing block 顶部起一个接一个垂直排列，水平方向上撑满整个宽度 (除非内部的盒子自己内部建立了新的 BFC)。
containing block
一般来说，盒子本身就为其子孙建立了 containing block，用来计算内部盒子的位置、大小，而对内部的盒子，具体采用哪个 containing block 来计算，需要分情况来讨论：

若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；
否则则由这个祖先元素的 padding box 构成。
根元素所在的 containing block 被称为 initial containing block，在我们常用的浏览器环境下，指的是原点与 canvas 重合，大小和 viewport 相同的矩形；
对于 position 为 static 或 relative 的元素，其 containing block 为祖先元素中最近的 block container box 的 content box (除 margin, border, padding 外的区域)；
对于 position:fixed 的元素，其 containing block 由 viewport 建立；
对于 position:absolute 的元素，则是先找到其祖先元素中最近的 position 属性非 static 的元素，然后判断：
如果都找不到，则为 initial containing block。
</pre>
<h3>9.position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样</h3>
<pre>
1、'display'、'position' 和 'float' 的相互关系；
2、position跟display、overflow、float下的margin collapse。
一、'display'、'position' 和 'float' 的相互关系
首先我们先来看下这3个属性。
  display 属性规定元素应该生成的框的类型。 block 象块类型元素一样显示，none 缺省值。
    象行内元素类型一样显示， inline-block 象行内元素一样显示，
    但其内容象块类型元素一样显示，list-item 象块类型元素一样显示，
    并添加样式列表标记（display 还有很多其他值设置，读者自行查找）。
  position 属性规定元素的定位类型。 
    absolute表示生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位；
    fixed（老IE不支持）生成绝对定位的元素，相对于浏览器窗口进行定位；relative生成相对定位的元素，
    相对于其正常位置进行定位；static  默认值。
    没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
  Float也是是一种布局方式，它定义元素在哪个方向浮动。以往这个属性总应用于图像，
    使文本围绕在图像周围，不过在 CSS 中，任何元素都可以浮动。浮动元素会生成一个块级框，
    而不论它本身是何种元素。 在布局过程中也经常会使用它来达到左右并排布局的效果。
那么这三种布局和框形成的关键特性( display )之间有什么关系呢，请看下面流程图：

转换对应表：
设定值	计算值
inline-table	table
inline, run-in, table-row-group, table-column, table-column-group, table-header-group, 
table-footer-group, table-row, table-cell, table-caption, inline-block	block
其他	同设定值
总的来说，可以把它看作是一个类似优先级的机制， "position:absolute" 和 "position:fixed" 优先级最高，
有它存在的时候，浮动不起作用，'display' 的值也需要调整； 
其次，元素的 'float' 特性的值不是 "none" 的时候或者它是根元素的时候，调整 'display' 的值； 
最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display' 特性值同设置值。
这从另一个侧面说明了一个问题：浮动或绝对定位的元素，只能是块元素或表格。
1. 'display' 的值为 'none'
如果 'display' 的值为 'none'，那么 'position' 和 'float' 不起作用。在这种情况下，元素不产生框。因此浮动和定位无效。
2. 'position' 的值是 'absolute' 或 'fixed'
否则，如果 'position' 的值是 'absolute' 或 'fixed'，框就是绝对定位的，'float' 计算后的值应该是 'none'，
并且，'display' 会被按照上表设置。 框的位置将由 'top'，'right'，'bottom' 和 'left' 属性和该框的包含块确定。
也就是说，当元素是绝对定位时，浮动失效，'display' 会被按规则重置。
示例代码：
&lt;script type="text/javascript"&gt;
  function getStyle(obj, style) { 
    var _style = (style == "float") ? "styleFloat" : style; 
    return document.defaultView ? document.defaultView.getComputedStyle(obj, null).getPropertyValue(style) : 
      obj.currentStyle[_style.replace(/-[a-z]/g, function() {
          return arguments[0].charAt(1).toUpperCase(); 
        })];
  }
  window.onload = function() { 
    document.getElementById("info").innerHTML = "float : " 
      + getStyle(document.getElementById("test"), "float") 
      +	 "&lt;br/&gt;display : " 
      + getStyle(document.getElementById("test"), "display");
  }
&lt;/script&gt;
&lt;div id="test" style="position:absolute; float:left;display:inline;"&gt;&lt;/div&gt;
&lt;div id="info"&gt;&lt;/div&gt;
上面代码中有一个既是绝对定位又是浮动的元素，以上代码可取出其 'display' 和 'float' 的计算值。
IE 中，'float' 值和 'display' 的特性值未发生变化，还是 "float: left; display: inline"。
其他浏览器中计算后的结果是："float: none; display: block"。
3. 'float' 的值不是 "none"
</pre>
<h3>10.对BFC规范的理解</h3>
<pre>
（W3C CSS 2.1 规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关 系和相互作用。）
11.css定义的权重
以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：
/*权重为1*/
div{
}
/*权重为10*/
.class1{
}
/*权重为100*/
#id1{
}
/*权重为100+1=101*/
#id1 div{
}
/*权重为10+1=11*/
.class1 div{
}
/*权重为10+10+1=21*/
.class1 .class2 div{
} 
如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 
</pre>
<h3>12.解释下浮动和它的工作原理？清除浮动的技巧</h3>
<pre>
浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。
使用空标签清除浮动。
这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。
使用overflow。
给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。
使用after伪对象清除浮动。
该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。
该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素。
</pre>
<h3>13.对WEB标准以及W3C的理解与认识</h3>
<pre>
标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和js脚本、
结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、
内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。
</pre>
<h3>14.CSS引入的方式有哪些? link和@import的区别是</h3>
<pre>
内联 内嵌 外链 导入
区别 ：同时加载
前者无兼容性，后者CSS2.1以下浏览器不支持
Link 支持使用javascript改变样式，后者不可
(1) link属于HTML标签，而@import是CSS提供的;
(2) 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;
(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;
(4) link方式的样式的权重 高于@import的权重.
</pre>
15.CSS选择符有哪些? 哪些属性可以继承?优先级算法如何计算?内联和important哪个优先级高
标签选择符 类选择符 id选择符
继承不如指定 Id&gt;class&gt;标签选择
后者优先级高

<h3>16.前端页面有哪三层构成，分别是什么?作用是什么</h3>
<pre>
结构层 Html 表示层 CSS 行为层 js
</pre>

<h3>17.css的基本语句构成是</h3>
<pre>
选择器{属性1:值1;属性2:值2;……}
</pre>

<h3>18.浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些,原因，解决方法是什么，常用hack的技巧 </h3>
<pre>
    * IE浏览器的内核Trident、 Mozilla的Gecko、google的WebKit、Opera内核Presto；
    * png24为的图片在iE6浏览器上出现背景，解决方案是做成PNG8.
    * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。
    * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 
    浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 
    这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
渐进识别的方式，从总体中逐渐排除局部。
    首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 
     接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

      css
          .bb{
           background-color:#f1ee18;/*所有识别*/
          .background-color:#00deff\9; /*IE6、7、8识别*/
          +background-color:#a200ff;/*IE6、7识别*/
          _background-color:#1e0bd1;/*IE6识别*/

          } 
    *  IE下,可以使用获取常规属性的方法来获取自定义属性,
       也可以使用getAttribute()获取自定义属性;
       Firefox下,只能使用getAttribute()获取自定义属性. 
       解决方法:统一通过getAttribute()获取自定义属性.
    *  IE下,even对象有x,y属性,但是没有pageX,pageY属性; 
      Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.
    * （条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。
    * Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.
    超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
    L-V-H-A :  a:link {} a:visited {} a:hover {} a:active {}
</pre>
19.写出几种IE6 BUG的解决方法
1.双边距BUG float引起的 使用display
2.3像素问题 使用float引起的 使用dislpay:inline -3px
3.超链接hover 点击后失效 使用正确的书写顺序 link visited hover active
4.Ie z-index问题 给父级添加position:relative
6.Min-height 最小高度 ！Important 解决’
7.select 在ie6下遮盖 使用iframe嵌套
8.为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08 line-height:1px）
20.标签上title与alt属性的区别是什么
Alt 当图片不显示是 用文字代表。
Title 为该属性提供信息
21.描述css reset的作用和用途
Reset重置浏览器的css默认属性 浏览器的品种不同，样式不同，然后重置，让他们统一。
22.解释css sprites，如何使用
Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量
23.浏览器标准模式和怪异模式之间的区别是什么
盒子模型 渲染模式的不同
使用 window.top.document.compatMode 可显示为什么模式
24.你如何对网站的文件和资源进行优化?期待的解决方案包括：
文件合并
文件最小化/文件压缩
使用CDN托管
缓存的使用

<h3>25.清除浮动的几种方式，各自的优缺点</h3>
<pre>
1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，，，增加无意义的标签）
2.使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）
3.是用afert伪元素清除浮动(用于非IE浏览器)
</pre>
SASS

<h3>26. 什么叫优雅降级和渐进增强</h3>
<pre>
优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，
  则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，
  针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，
  使之在旧式浏览器上以某种形式降级体验却不至于完全失效.

渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,
  向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
</pre>
<h3>27.display:none和visibility:hidden的区别 </h3>
<pre>
display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。
visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。
</pre>
<h3>28. position的absolute与fixed共同点与不同点 </h3>
<pre>
A：共同点：
1.改变行内元素的呈现方式，display被置为block；2.让元素脱离普通流，不占据空间；3.默认会覆盖到非定位元素上

B不同点：
absolute的”根元素“是可以设置的，而fixed的”根元素“固定为浏览器窗口。当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。
</pre>

<h3>29. 解释下 CSS sprites，以及你要如何在页面或网站中使用它</h3>
<pre>
CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，
“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。
这样可以减少很多图片请求的开销，因为请求耗时比较长；请求虽然可以并发，
但是也有限制，一般浏览器都是6个。对于未来而言，就不需要这样做了，因为有了`http2`。
</pre>

<h2>JavaScript</h2>
<h3>1.JavaScript原型，原型链,有什么特点</h3>
<pre>
*  原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
*  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。
* JavaScript的数据对象有那些属性值？
　　writable：这个属性的值是否可以改。
configurable：这个属性的配置是否可以删除，修改。
　　enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。
　　value：属性值。
* 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性。
function clone(proto) {
　function Dummy() { }
　Dummy.prototype = proto;
　Dummy.prototype.constructor = Dummy;
　return new Dummy(); //等价于Object.create(Person);
 } 
function object(old) {
  function F() {};
  F.prototype = old;
  return new F();
}
var newObj = object(oldObject)
</pre>
<h3>2.eval是做什么的</h3>
<pre>
它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
</pre>
<h3>4.Node.js的适用场景</h3>
<pre>
高并发、聊天、实时消息推送
</pre>
<h3>5.介绍js的基本数据类型</h3>
<pre>
number,string,boolean,object,undefined
</pre>
<h3>6.Javascript如何实现继承</h3>
<pre>
通过原型和构造器
</pre>
<h3>7.["1", "2", "3"].map(parseInt) 答案是多少</h3>
<pre>
 [1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix) 但 map 传了 3 个 (element, index, array)
 </pre>
<h3>8.如何创建一个对象? （画出此对象的内存图）</h3>
<pre>
function Person(name, age) {
   this.name = name;
   this.age = age;
   this.sing = function() { alert(this.name) } 
} 
</pre>
<h3>9.谈谈This对象的理解</h3>
<pre>
this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。


但是有一个总原则，那就是this指的是调用函数的那个对象。

this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象 
</pre>
<h3>10.事件是，IE与火狐的事件机制有什么区别，如何阻止冒泡</h3>
<pre>
 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。  
 2. 事件处理机制：IE是事件冒泡、火狐是 事件捕获；
 3. ev.stopPropagation();
</pre>
<h3>12.什么是闭包（closure），为什么要用它</h3>
<pre>
执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在.
使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源，
因为say667()的内部函数的执行需要依赖say667()中的变量。这是对闭包作用的非常直白的描述.
function say667() {
    // Local variable that ends up within closure
    var num = 666;
    var sayAlert = function() { alert(num); }
    num++;
    return sayAlert;
}
 
var sayAlert = say667();
sayAlert()//执行结果应该弹出的667  
</pre>
<h3>13."use strict";是什么意思，使用它的好处和坏处分别是什么</h3>
<pre>
ECMAscript 5添加了第二种运行模式："严格模式"(strict mode)。顾名思义，这种模式使得Javascript在更严格的条件下运行。
　　设立"严格模式"的目的，主要有以下几个：
　　1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
　　2. 消除代码运行的一些不安全之处，保证代码运行的安全;
　　3. 提高编译器效率，增加运行速度;
　　4. 为未来新版本的Javascript做好铺垫。
　　注：经过测试 IE6,7,8,9 均不支持严格模式。
　　缺点：
　　现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。
    这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。
</pre>
<h3>14.如何判断一个对象是否属于某个类</h3>
<pre>
使用instanceof
if(a instanceof Person){
  alert('yes');
}
</pre>
<h3>15.new操作符具体干了什么呢</h3>
<pre>
  1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
  2、属性和方法被加入到 this 引用的对象中。
  3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj); 
</pre>
<h3>16.Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是</h3>
<pre>
hasOwnProperty
</pre>
<h3>17.JSON 的了解</h3>
<pre>
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。
它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
{'age':'12', 'name':'back'}
</pre>
<h3>18.js延迟加载的方式有哪些</h3>
<pre>
defer和async、动态创建DOM方式（用得最多）、按需异步载入js
</pre>
<h3>19.ajax 是什么? 同步和异步的区别? 如何解决跨域问题</h3>
<pre>
通过异步模式，提升了用户体验
 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
 Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
Ajax的最大的特点是什么。
Ajax可以实现动态不刷新（局部刷新）
readyState属性 状态 有5个可取值： 0=未初始化 ，1=正在加载 2=以加载，3=交互中，4=完成
ajax的缺点
ajax不支持浏览器back按钮。
安全问题 AJAX暴露了与服务器交互的细节。
对搜索引擎的支持比较弱。
破坏了程序的异常机制。
不容易调试。
跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面
</pre>
<h3>20. 对Node的优点和缺点提出了自己的看法</h3>
<pre>
*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
</pre>
<h3>21. 说出这道题的答案</h3>
<pre>
(function(x){
  delete x;
  alert(x);
})(1+5);
函数参数无法delete删除，delete只能删除通过for in访问的属性。
当然，删除失败也不会报错，所以代码运行会弹出“6”。
</pre>
<h3>22.模块化怎么做</h3>
<pre>
立即执行函数,不暴露私有成员
var module1 = (function(){
　　var _count = 0;
　　var m1 = function(){
　　　　//...
　　};
　　var m2 = function(){
　　　　//...
　　};
　　return {
　　　　m1 : m1,
　　　　m2 : m2
　　};
})(); 
</pre>
<h3>24.异步加载的方式有哪些</h3>
<pre>
(1) defer，只支持IE
(2) async：
(3)创建script，插入到DOM中，加载完毕后callBack
</pre>
<h3>25.documen.write和 innerHTML的区别</h3>
<pre>
document.write只能重绘整个页面
innerHTML可以重绘页面的一部分
</pre>
<h3>26..call() 和 .apply() 的区别</h3>
<pre>
例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 
注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。
function add(a,b){
    alert(a+b);
}
 
function sub(a,b){
    alert(a-b);
}
 
add.call(sub,3,1);  
</pre>
<h3>27.jQuery与jQuery UI 有啥区别</h3>
<pre>
*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。

*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等
</pre>
<h3>28.jquery 中如何将数组转化为json字符串，然后再转化回来</h3>
<pre>
jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：
$.fn.stringifyArray = function(array) {
  return JSON.stringify(array)
}
 
$.fn.parseArray = function(array) {
  return JSON.parse(array)
} 
然后调用：
$("").stringifyArray(array) 
</pre>
<h3>29.针对 jQuery 的优化方法</h3>
<pre>
*基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。

*频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。   
 比如：var str=$("a").attr("href");

*for (var i = size; i &lt; arr.length; i++) {}
 for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快： 
 for (var i = size, length = arr.length; i &lt; length; i++) {}
</pre>
<h3>30.JavaScript中的作用域与变量声明提升</h3>
<pre>
如何编写高性能的Javascript？
那些操作会造成内存泄漏？
内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。
如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
</pre>
<h3>31. javascript的typeof返回哪些数据类型</h3>
<pre>
Object number function boolean underfind
</pre>

<h3>32.例举3种强制类型转换和2种隐式类型转换?</h3>
<pre>
强制（parseInt,parseFloat,number）
隐式（== – ===）
</pre>
<h3>33.split() join() 的区别</h3>
<pre>
前者是切割成数组的形式，后者是将数组转换成字符串
</pre>
<h3>34.数组方法pop() push() unshift() shift()</h3>
<pre>
Push()尾部添加 pop()尾部删除
Unshift()头部添加 shift()头部删除
</pre>
<h3>35.IE和DOM事件流的区别</h3>
<pre>
1.参数不一样
2.事件加不加on
3.this指向问题
</pre>
<h3>36.IE和标准下有哪些兼容性的写法</h3>
<pre>
Var ev = ev || window.event
document.documentElement.clientWidth || document.body.clientWidth
Var target = ev.srcElement||ev.target
</pre>
<h3>37.ajax请求的时候get 和post方式的区别</h3>
<pre>
一个在url后面 一个放在虚拟载体里面
有大小限制
安全问题
应用不同 一个是论坛等只需要请求的，一个是类似修改密码的
</pre>
<h3>38.call和apply的区别</h3>
<pre>
Object.call(this,obj1,obj2,obj3)
Object.apply(this,arguments)
</pre>
<h3>39.ajax请求时，如何解释json数据</h3>
<pre>
使用eval parse 鉴于安全性考虑 使用parse更靠谱
</pre>
<h3>40.写一个获取非行间样式的函数</h3>
<pre>
function getStyle(obj,attr,value){
  if(!value){
    if(obj.currentStyle){
      return obj.currentStyle(attr){
        obj.getComputedStyle(attr,false)
      }
    }else{
      obj.style[attr]=value
    }
  }
}
</pre>
<h3>41.事件委托是什么</h3>
<pre>
让利用事件冒泡的原理，让自己的所触发的事件，让他的父元素代替执行！
http://www.webasily.com/?p=78 例子可见此链接
</pre>
<h3>42.如何阻止事件冒泡和默认事件</h3>
<pre>
canceBubble return false
</pre>
<h3>43.添加 删除 替换 插入到某个接点的方法</h3>
<pre>
obj.appendChidl()
obj.innersetBefore
obj.replaceChild
obj.removeChild
</pre>
<h3>44.解释jsonp的原理，以及为什么不是真正的ajax</h3>
<pre>
动态创建script标签，回调函数
Ajax是页面无刷新请求数据操作
</pre>
<h3>45.javascript的本地对象，内置对象和宿主对象</h3>
<pre>
本地对象为array obj regexp等可以new实例化
内置对象为gload Math 等不可以实例化的
宿主为浏览器自带的document,window 等
</pre>
<h3>49.document load 和document ready的区别</h3>
<pre>
Document.onload 是在结构和样式加载完才执行js
Document.ready原生种没有这个方法，jquery中有 $().ready(function)
</pre>
<h3>50.”==”和“===”的不同</h3>
<pre>
前者会自动转换类型
后者不会
</pre>
<h3>51.javascript的同源策略</h3>
<pre>
一段脚本只能读取来自于同一来源的窗口和文档的属性，这里的同一来源指的是主机名、协议和端口号的组合
</pre>
<h3>52.编写一个数组去重的方法</h3>
<pre>
function oSort(arr){
  var result ={};
  var newArr=[];
  for(var i=0;i&lt;arr.length;i++){
    if(!result[arr]){
      newArr.push(arr);
      result[arr]=1;
    }
  }
  return newArr;
}

if(!result[arr \[i\]){
  newArr.push(arr \[i\);
  result[arr \[i\]=1;
}
</pre>
<h3>53. 哪些操作会造成内存泄漏</h3>
<pre>
内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
</pre>
<h3>54. jquery 中如何将数组转化为json字符串，然后再转化回来</h3>
<pre>
    jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：
    $.fn.stringifyArray = function(array) {
        return JSON.stringify(array)
    }
    $.fn.parseArray = function(array) {
        return JSON.parse(array)
    } 
    然后调用：
    $("").stringifyArray(array)
</pre>
<h3>55. Jquery与jQuery UI 有什么区别</h3>
<pre>
    *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。
    *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
     提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等
</pre>
  </div>
</body>
</html>